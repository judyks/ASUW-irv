<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IRV ASUW Elections</title>
    <style>
      @font-face {
        font-family: "Encode Sans";
        src: url("Encode Sans Normal/encode-sans.ttf") format("ttf");
      }
      table {
        border-collapse: collapse;
        width: 50%;
      }
      th,
      td {
        border: 1px solid #dddddd;
        text-align: left;
        padding: 8px;
      }
      th {
        background-color: #f2f2f2;
      }
      body {
        background-color: #fbf9f9;
        margin: 0;
        padding: 40px;
        font: "Encode Sans";
      }
      .title {
        text-align: center;
      }
      h2 {
        text-align: center;
        font-size: large;
        margin-top: 50px;
        margin-bottom: 20px;
        background-color: #4b2e83;
        color: #fffcfc;
        border: solid 0.5px #4b2e83;
        border-radius: 20px;
        padding: 10px;
        width: 50%;
      }
      h3 {
        font-size: large;
        color: #4b2e83;
        padding-top: 10px;
      }
      #positionDropdown {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #cccccc;
        background-color: #ffffff;
        margin-top: 20px;
        margin-bottom: 30px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1 class="title">ASUW IRV Elections</h1>
    </header>
    <main>
      <section>
        <input type="file" id="fileInput" accept=".csv" />
        <button id="processButton" disabled>Process IRV</button>
        <select id="positionDropdown" style="display: none"></select>
        <button id="resultsByRoundButton" style="display: none">
          Results by Round
        </button>
        <section id="winnersOverview"></section>
        <div id="output"></div>
        <div id="roundResultsContainer" style="display: none"></div>
      </section>
    </main>

    <script>
      let globalCsvData = null;
      let winners = {};

      document.addEventListener("DOMContentLoaded", () => {
        const fileInput = document.getElementById("fileInput");
        const processButton = document.getElementById("processButton");
        const resultsByRoundButton = document.getElementById(
          "resultsByRoundButton"
        );

        fileInput.addEventListener("change", handleFileSelect);
        processButton.addEventListener("click", processButtonClick);
        document
          .getElementById("positionDropdown")
          .addEventListener("change", updateLocationHash);
        resultsByRoundButton.addEventListener("click", toggleResultsDisplay);
      });

      function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          globalCsvData = e.target.result;
          document.getElementById("processButton").disabled = false;
        };
        reader.readAsText(file);
      }

      function processButtonClick() {
        if (globalCsvData) {
          processData(globalCsvData);
        }
      }

      function updateLocationHash() {
        const positionDropdown = document.getElementById("positionDropdown");
        if (positionDropdown.value) {
          location.hash = `#${positionDropdown.value}`;
        }
      }

      function toggleResultsDisplay() {
        const roundResultsContainer = document.getElementById(
          "roundResultsContainer"
        );
        const outputContainer = document.getElementById("output");
        const positionDropdown = document.getElementById("positionDropdown");
        const winnersOverview = document.getElementById("winnersOverview");
        const isHidden = roundResultsContainer.style.display === "none";

        roundResultsContainer.style.display = isHidden ? "block" : "none";
        outputContainer.style.display = isHidden ? "none" : "block";
        positionDropdown.style.display = isHidden ? "none" : "block";
        winnersOverview.style.display = isHidden ? "none" : "block";
        document.getElementById("resultsByRoundButton").textContent = isHidden
          ? "Results by position"
          : "Results by Round";
      }

      function processData(csvData) {
        const lines = csvData.split("\n");
        const headers = lines[0].split(",");
        const positions = headers.map((header) =>
          header.split("presidential")[0].trim()
        );
        let uniquePositions = [...new Set(positions)];

        initializePositionDropdown(uniquePositions);
        processPositions(positions, lines, uniquePositions);
      }

      function initializePositionDropdown(uniquePositions) {
        const positionDropdown = document.getElementById("positionDropdown");
        positionDropdown.style.display = "block";
        positionDropdown.innerHTML =
          '<option value="">Select position</option>' +
          uniquePositions
            .map(
              (position) => `<option value="${position}">${position}</option>`
            )
            .join("");
      }

      function processPositions(positions, lines, uniquePositions) {
        let output = "Results by Position";
        let roundResults = {};

        uniquePositions.forEach((position) => {
          if (!isAllowedPosition(position)) return;

          const { positionOutput, positionRoundResults } = createPositionOutput(
            position,
            lines
          );
          output += `<div id="${position}">${positionOutput}</div>`;

          positionRoundResults.forEach((roundResult, roundIndex) => {
            roundResults[roundIndex] = roundResults[roundIndex] || [];
            roundResults[roundIndex].push(
              `<h4>Position: ${position}</h4>${roundResult}`
            );
          });
        });

        document.getElementById("output").innerHTML = output;
        updateWinnersOverview();
        document.getElementById("resultsByRoundButton").style.display = "block";
        displayRoundResults(roundResults);
      }

      function isAllowedPosition(position) {
        const allowedHeaders = [
          "President",
          "Vice President",
          "Director of University Affairs",
          "Director of Internal Policy",
          "Director of Community Relations",
          "Director of Diversity Efforts",
          "Director of Programming",
          "Director of Campus Partnerships",
        ];
        return allowedHeaders.some((header) =>
          position.toLowerCase().startsWith(header.toLowerCase())
        );
      }

      function createPositionOutput(position, lines) {
        let output = `<h2>${position}</h2>`;
        let positionVotes = getPositionVotes(position, lines);
        let round = 1;
        let eliminatedCandidates = new Set();
        let positionRoundResults = [];
        let winnerDeclared = false;

        while (!winnerDeclared) {
          let { voteCounts, totalVotes } = countVotes(
            positionVotes,
            eliminatedCandidates
          );
          if (Object.keys(voteCounts).length === 0) {
            output += `<p>No remaining candidates to process for this position.</p>`;
            break;
          }

          let sortedVotes = sortVotes(voteCounts);
          let { newEliminatedCandidates, eliminatedThisRound, isTie } =
            updateEliminatedCandidates(
              sortedVotes,
              eliminatedCandidates,
              totalVotes
            );

          let roundOutput = generateRoundOutput(
            round,
            sortedVotes,
            totalVotes,
            eliminatedThisRound,
            eliminatedCandidates
          );
          output += roundOutput;
          positionRoundResults.push(roundOutput);

          if (
            isTie ||
            sortedVotes[0][1] > totalVotes / 2 ||
            sortedVotes.length === 1
          ) {
            output += declareWinner(sortedVotes, totalVotes, position);
            winnerDeclared = true;
          } else {
            eliminatedCandidates = newEliminatedCandidates;
            round++;
          }
        }

        return { positionOutput: output, positionRoundResults };
      }

      function getPositionVotes(position, lines) {
        return lines
          .slice(1)
          .map((line) =>
            line
              .split(",")
              .filter((_, index) =>
                lines[0].split(",")[index].trim().startsWith(position)
              )
              .map((pref) => pref.trim())
              .filter((pref) => pref)
          )
          .filter((vote) => vote.length > 0);
      }

      function countVotes(positionVotes, eliminatedCandidates) {
        let voteCounts = {};
        let totalVotes = 0;

        positionVotes.forEach((vote) => {
          const firstPref = vote.find(
            (pref) => !eliminatedCandidates.has(pref)
          );
          if (firstPref) {
            voteCounts[firstPref] = (voteCounts[firstPref] || 0) + 1;
            totalVotes++;
          }
        });

        return { voteCounts, totalVotes };
      }

      function sortVotes(voteCounts) {
        return Object.entries(voteCounts).sort((a, b) => b[1] - a[1]);
      }

      function generateRoundOutput(
        round,
        sortedVotes,
        totalVotes,
        eliminatedThisRound,
        allEliminatedCandidates
      ) {
        let output = `<h3>Round ${round}</h3><table>`;
        output += `<tr><th>Candidate</th><th>Votes</th><th>Percentage</th></tr>`;

        sortedVotes.forEach(([candidate, votes]) => {
          const percentage = ((votes / totalVotes) * 100).toFixed(2);
          output += `<tr><td>${candidate}</td><td>${votes}</td><td>${percentage}%</td></tr>`;
        });

        output += `</table>`;
        if (eliminatedThisRound.length > 0) {
          output += `<p>Eliminated this round: ${eliminatedThisRound.join(
            ", "
          )}</p>`;
        }
        if (allEliminatedCandidates.size > 0) {
          output += `<p>Eliminated candidates so far: ${Array.from(
            allEliminatedCandidates
          ).join(", ")}</p>`;
        }

        return output;
      }

      function declareWinner(sortedVotes, totalVotes, position) {
        const winner = sortedVotes[0][0];
        const maxVotes = sortedVotes[0][1];
        const winnerPercentage = ((maxVotes / totalVotes) * 100).toFixed(2);
        winners[position] = {
          name: winner,
          votes: maxVotes,
          percentage: winnerPercentage,
        };
        return `<h4>Winner: ${winner} with ${maxVotes} votes (${winnerPercentage}% of total votes)</h4>`;
      }

      function updateEliminatedCandidates(
        sortedVotes,
        eliminatedCandidates,
        totalVotes
      ) {
        let newEliminatedCandidates = new Set(eliminatedCandidates);
        let minVotes = sortedVotes[sortedVotes.length - 1][1];
        let candidatesForElimination = sortedVotes
          .filter(([_, votes]) => votes === minVotes)
          .map(([candidate]) => candidate);
        let isTie =
          sortedVotes.length === 2 && sortedVotes[0][1] === sortedVotes[1][1];

        if (!isTie) {
          candidatesForElimination.forEach((candidate) =>
            newEliminatedCandidates.add(candidate)
          );
        }

        return {
          newEliminatedCandidates,
          eliminatedThisRound: isTie ? [] : candidatesForElimination,
          isTie,
        };
      }

      // currently overview only shows positions with winners (doesn't show results for positions with ties)
      function updateWinnersOverview() {
        let overviewHtml = "<h3>Overview</h3><table>";
        overviewHtml +=
          "<tr><th>Position</th><th>Winner</th><th>Votes</th><th>Percentage</th></tr>";

        for (const position in winners) {
          overviewHtml += `<tr><td>${position}</td><td>${winners[position].name}</td><td>${winners[position].votes}</td><td>${winners[position].percentage}%</td></tr>`;
        }

        overviewHtml += "</table>";
        document.getElementById("winnersOverview").innerHTML = overviewHtml;
      }

      function displayRoundResults(roundResults) {
        let roundResultsOutput = "<h1>Results by round</h1>";
        Object.keys(roundResults).forEach((round) => {
          roundResultsOutput +=
            `<h2>Round ${parseInt(round) + 1}</h2>` +
            roundResults[round].join("");
        });
        document.getElementById("roundResultsContainer").innerHTML =
          roundResultsOutput;
      }
    </script>
  </body>
</html>
